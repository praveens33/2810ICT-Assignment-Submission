Github Organisation.
The github repository of the project follows the standard structure generated by Angular CLI, the directories are logically organized, src/ contains  source code for the application, src/app/ contains all components, services and models. The auth/,chat/ and admin/ are the feature module, the services/ contain all services allowing for services to be reused and called throughout the application. And models/ defines data structures while guards/ contains route guards, for example admin-guard.ts that enforces security rules on dashboard. The version control strategy was guided by atomic commits and conventional commit messages. Atomic commits means that the commit represents a single complete work, rather than sporadic commits, and conventional commit messages means that the format of commit message follows <type>:<description> format, types vary such as “feat” (feature) or “fix”.

Server-Side Data Entities
The core data of the application are to be stored on a server in part 2,  and represented by the following models:
User: chat users without admin privileges. 
{  "id": "u0",   "username": "super",   "roles": ["Super Admin", "User"],   "groups": ["g1", "g2"],   “channels”: string[“c1”,”c2”]}
Group: A collection of users, administered by one or more admins. Groups contain channels.
{ "id": "g2",   "name": "Group 1",   "admins": ["u0"],   "requests": ["u2"]}
Channel: A specific chat room within a group where messages are posted.
{   "id": "c1",   "name": "announcements",  "groupId": "g1" }
Message: An individual message sent by a user to a specific channel.
{  "id": "m1",  "channelId": "c1",  "username": "super",  "text": "Hello everyone!"}
Angular Client Architecture
The client-side application is built with Angular, following a modern, service-oriented architecture.
Models:
The application uses TypeScript interfaces (e.g., User, Group, Channel) to ensure type safety and define the structure of data received from the server. These are defined in user.model.ts and chat.ts.
Components: The UI is divided into key components:
login: Handles user authentication.
register: Handles new user registration.
chat-view: The main user interface for viewing groups, channels, and messages, and for interacting with the chat.
dashboard: An administrative panel for Super Admins and Group Admins to manage users, groups, create users, channel access, channel creation and join requests
Services: Logic and state management are centralized in services to ensure a single source of truth.
AuthService (auth.ts): Manages the current user's state (logged in/out), handles authentication logic, and stores the current user's session data in localStorage.
ChatService (chat.ts): Acts as the primary state management service. It fetches, stores, and manages all chat-related data (users, groups, channels), messages. It uses RxJS 
BehaviorSubjects to create observable streams (users$, groups$) that components can subscribe to for real-time UI updates.
Routes (app.routes.ts): The application's navigation is defined with the following routes:
o	/login: Displays the LoginComponent.
o	/register: Displays the RegisterComponent.
o	/chat: Displays the ChatViewComponent for authenticated users.
o	/admin: Displays the DashboardComponent, protected by an adminGuard to restrict access to authorized admins.








Node.js Server Architecture
For the phase 1 of the assignment, the Node.js server functionality is done entirely within the Angular application by the ChatService and AuthService, which allows the front-end to be functional and localStorage stimulates a persistent database
Data Storage Simulation:
In-Memory Database: The private arrays within ChatService (e.g., private users: User[], private groups: Group[]) act as a live, in-memory database.
Persistent Storage: The ChatService constructor reads from localStorage (localStorage.getItem(...)) to load the state, and its methods write back to localStorage (localStorage.setItem(...)) after every modification. This directly simulates the behavior of a Node.js server interacting with a persistent database like MongoDB.
Business Logic & Controller Emulation:
The public methods in the services directly represent the controller functions of a Node.js server. They contain the business logic for manipulating data.
Authentication Logic (auth.ts): The AuthService.login() method emulates an authentication controller. It receives credentials from the LoginComponent, validates them against the "user database" (provided by ChatService.getUsers()), and creates a "session" by setting currentUser and saving it to localStorage.
Resource Management Logic (chat.ts): Methods such as  approveJoinRequest(), createGroup(), and promoteToGroupAdmin() contain the logic a Node.js controller would use to find records, update them according to business rules (e.g., checking for super admin privileges, group admin privelleges), and save the changes back to the database.
API Route Emulation:
Component-to-service method calls in Angular directly simulate client-to-server API requests. There are no global variables; data is encapsulated within the services.
When the DashboardComponent calls chatService.removeUser(userId), this is functionally identical to the front-end sending a DELETE /api/users/:userId request to a server.
When the ChatViewComponent calls chatService.requestToJoinGroup(userId, groupId), it mirrors a POST /api/groups/:id/requests API call.
This emulation provides a complete and realistic development environment for the front-end, fulfilling the architectural requirements for Phase 1 before transitioning to a true MEAN stack in Phase 2.
Proposed Server-Side API Routes 
The following RESTful API endpoints are designed for the server to support the client's functionality.
•	Method: POST, Route: /api/auth/login, Purpose: Authenticate a user. Parameters: body: {email, password}, Return Value: { user: User, token: string }
•	Method: GET, Route: /api/groups, Purpose: Get a list of all groups. Parameters: None, Return Value: Group[]
•	Method: GET, Route: /api/users, Purpose: Get a list of all users. Parameters: None, Return Value: User[]
•	Method: POST, Route: /api/groups/:id/requests, Purpose: A user requests to join a group. Parameters: body: {userId}, Return Value: { success: true }
•	Method: POST, Route: /api/groups/:id/approve, Purpose: An admin approves a join request. Parameters: body: {userIdToApprove}, Return Value: { success: true, updatedUser: User, updatedGroup: Group }
•	Method: DELETE, Route: /api/groups/:id/users/:userId, Purpose: A group admin removes a user from a group. Parameters: None, Return Value: { success: true }
•	Method: POST, Route: /api/users/:id/promote, Purpose: A super admin promotes a user to Group Admin. Parameters: body: {role: 'Group Admin'}, Return Value: { success: true, updatedUser: User }
 Client-Server Interaction Example: User Requests to Join a Group
A logged-in user (NormalUser) is on the /chat page. They see a list of available groups they are not yet members of.
1)The user clicks the "Join" button next to a group. This action calls the requestTojoinGroup(groupId) method within the chat-view
Client - Service Logic (chat service (chat.ts)):
The chat-view.ts component calls:
this.chatService.requestToJoinGroup(currentUser.id, groupId)
Inside chat.ts, the requestToJoinGroup function executes the following steps:
It makes sure that the User is not already in the group requess.
It creates a new, updated array of groups by mapping over the existing one.
It finds the specific group matching the groupId and returns a new group object with the current user's ID added to its requests array.
Data Persistence (Phase 1): The service then saves the entire updated groups array to the browser's localStorage by calling localStorage.setItem('chat_groups', JSON.stringify(this.groups)). This is the key step that ensures the request is not lost when the application reloads.
Fiinally, the service calls this.groupsSource.next(this.groups) to broadcast the state change to any active subscribers. The user gets an alert("Request sent") and their view remains unchanged.



	
